JAVA内存模型(JMM:JAVA MEMORY MODEL)
	java内存模型规范，它规定了一个线程 
	1.如何 和 何时 可以看到由其他线程修改过的共享变量的值
	2.如何 同步的访问共享变量
	
	栈(Stack = thread stack * N ):存放基本类型变量,如int,double......
	堆(Heap):存放对象和运行实例，动态规划内存，生命周期由gcc(java垃圾回收机制)控制
	
	*多个thread stack(线程栈) 同时调用一个存放在heap上的对象实例Object，则这些thread stack同时拥有Object中的成员变量的私有拷贝(副本)
	
内存模型抽象结构图:
	线程A ——> 本地内存A(包含共享变量副本) ————> {JMM控制} ————>主内存
	
8中同步操作:
	1.lock(锁定):作用于主内存的变量，把一个变量标识为一条线程独占状态
	2.unlock(解锁):作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
	3.read(读取):作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
	4.load(载入):作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中
	5.use(使用):作用于工作内存的变量，把工作内存的一个变量值传递给执行引擎
	6.assign(赋值):作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量
	7.store(存储):作用于工作内存的变量，把工作内存的一个变量的值传送到主存中，以便随后的write操作
	8.write(写入):作用于主内存的变量，把一store操作从工作内存中的一个变量的值传送到主存变量中
	
同步规则:
	1.保证read和load的顺序执行，store和write的顺序执行,但不保证read和load(或者store和write)连续执行
	2.不允许read和load、store和write操作之一单独出现
	3.同步到主内存的线程之前，不允许线程丢弃它最近的assign操作，即变量发生改变后才必须同步回内存中
	4.一个新的变量只能在主内存中诞生，不允许在工作内存中直接用一个未被初始化的变量,即在一个变量use/store之前必须执行过assign和load操作
	5.同一时刻只允许一个线程被lock，但lock操作可以被一个线程在不同时刻重复执行多次，lock和unlock操作都是成对出现的
	6.如果一个变量执行lock操作,将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assigb操作初始化变量的值
	7.unlock之前必须将变量同步回主内存,unlock前必须先stroe和write
	